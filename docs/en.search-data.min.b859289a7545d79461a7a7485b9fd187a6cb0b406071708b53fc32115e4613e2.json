[{"id":0,"href":"/cherrypick-site/posts/library_post/","title":"CherryPick DI","section":"Blog","content":"CherryPick DI #  DI-контейнер – это библиотека, которая обеспечивает функциональность механизма внедрения зависимостей.\nСодержание #   Предисловие Возможности библиотеки Компоненты библиотеки  3.1. Scope 3.2. Module 3.3. Binding   Пример использования Заключение  1. Предисловие #  Первые попытки разработать свой DI для пет проектов написанных на Flutter SDK были начаты в конце 2019 года.\nСподвигло меня на этот шаг несколько причин:\n На тот момент я не нашел DI в pub.dev с возможностью делить контейнер на scope (возможно плохо искал) Упростить работу с зависимостями в проекте Желание написать собственный DI Иметь в арсенале простой DI (надеюсь с простым API)  В июне 2020 был принято решение вести разработку в публичном репозитории.\nВ марте 2021 было добавлена поддержка null-safety.\nВ апреле 2021 было переработано api библиотеки.\nС апреля 2021 было принято решение использовать библиотеку в разработке коммерческого проекта.\n2. Возможности библиотеки #  Основные возможности DI контейнера:\n Инициализация экземпляра с именем Инициализация экземпляра как singleton Разделение контейнера на области видимости (scopes)  3. Основные компоненты DI #  Библиотека состоит из трех основных компонентов:\n Scope Module Binding  3.1. Scope #  Scope - это контейнер, который хранит все дерево зависимостей (scope,modules,instances). Через scope можно получить доступ к instance, для этого нужно вызвать метод resolve\u0026lt;T\u0026gt;() и указать тип объекта, а так же можно передать дополнительные параметры.\nScope определяет область видимости и время жизни зависимостей.\nScope в приложении образуют древовидную иерархическую структуру. Например, у вас может быть Scope для всего приложения, и дочерний Scope для конкретного экрана или группы экранов.\nЧтобы получить объект Scope, его нужно “открыть”. Для простоты сделаем один Scope на всё приложение:\n final rootScope = CherryPick.openScope(named: \u0026#39;appScope\u0026#39;); Если повторно открыть Scope с тем же самым именем, мы получим уже существующий экземпляр Scope.\nКогда Scope перестанет быть нужным, его (и всё дерево “дочерних” Scope) можно будет закрыть с помощью метода CherryPick.closeScope(name)\n3.2. Module #  Module - это набор правил, по которым CherryPick будет разрешать зависимости в конкретном Scope. Пользователь в своем модуле должен реализовать метод void builder(Scope currentScope). Модули добавляются в Scope с помощью метода scope.installModules(…), после чего Scope может разрешать зависимости по правилам, определённым в его модулях.\nПример:\nclass AppModule extends Module {  @override  void builder(Scope currentScope) {  bind\u0026lt;ApiClient\u0026gt;().toInstance(ApiClientMock());  } } 3.3. Binding #  Binding - по сути это конфигуратор для пользовательского instance, который содержит методы для конфигурирования зависимости.\nЕсть два основных метода для инициализации пользовательского instance toInstance() и toProvide() и вспомогательных withName() и singleton().\ntoInstance() - принимает готовый экземпляр\ntoProvide() - принимает функцию provider (конструктор экземпляра)\nwithName() - принимает строку для именования экземпляра. По этому имени можно будет извлечь instance из DI контейнера\nsingleton() - устанавливает флаг в Binding, который говорит DI контейнеру, что зависимость одна.\nПример:\n // инициализация экземпляра текстовой строки через метод toInstance()  bind\u0026lt;String\u0026gt;().toInstance(\u0026#34;hello world\u0026#34;);   // или   // инициализация экземпляра текстовой строки  bind\u0026lt;String\u0026gt;().toProvide(() =\u0026gt; \u0026#34;hello world\u0026#34;);   // инициализация экземпляра строки с именем  bind\u0026lt;String\u0026gt;().withName(\u0026#34;my_string\u0026#34;).toInstance(\u0026#34;hello world\u0026#34;);  // или  bind\u0026lt;String\u0026gt;().withName(\u0026#34;my_string\u0026#34;).toProvide(() =\u0026gt; \u0026#34;hello world\u0026#34;);   // инициализация экземпляра, как singleton  bind\u0026lt;String\u0026gt;().toInstance(\u0026#34;hello world\u0026#34;);  // или  bind\u0026lt;String\u0026gt;().toProvide(() =\u0026gt; \u0026#34;hello world\u0026#34;).singleton(); 4. Пример приложения #  import \u0026#39;dart:async\u0026#39;; import \u0026#39;package:meta/meta.dart\u0026#39;; import \u0026#39;package:cherrypick/cherrypick.dart\u0026#39;;  class AppModule extends Module {  @override  void builder(Scope currentScope) {  bind\u0026lt;ApiClient\u0026gt;().withName(\u0026#34;apiClientMock\u0026#34;).toInstance(ApiClientMock());  bind\u0026lt;ApiClient\u0026gt;().withName(\u0026#34;apiClientImpl\u0026#34;).toInstance(ApiClientImpl());  } }  class FeatureModule extends Module {  bool isMock;   FeatureModule({required this.isMock});   @override  void builder(Scope currentScope) {  bind\u0026lt;DataRepository\u0026gt;()  .withName(\u0026#34;networkRepo\u0026#34;)  .toProvide(  () =\u0026gt; NetworkDataRepository(  currentScope.resolve\u0026lt;ApiClient\u0026gt;(  named: isMock ? \u0026#34;apiClientMock\u0026#34; : \u0026#34;apiClientImpl\u0026#34;,  ),  ),  )  .singleton();  bind\u0026lt;DataBloc\u0026gt;().toProvide(  () =\u0026gt; DataBloc(  currentScope.resolve\u0026lt;DataRepository\u0026gt;(named: \u0026#34;networkRepo\u0026#34;),  ),  );  } }  void main() async {  final scope = openRootScope().installModules([  AppModule(),  ]);   final subScope = scope  .openSubScope(\u0026#34;featureScope\u0026#34;)  .installModules([FeatureModule(isMock: true)]);   final dataBloc = subScope.resolve\u0026lt;DataBloc\u0026gt;();  dataBloc.data.listen((d) =\u0026gt; print(\u0026#39;Received data: $d\u0026#39;),  onError: (e) =\u0026gt; print(\u0026#39;Error: $e\u0026#39;), onDone: () =\u0026gt; print(\u0026#39;DONE\u0026#39;));   await dataBloc.fetchData(); }  class DataBloc {  final DataRepository _dataRepository;   Stream\u0026lt;String\u0026gt; get data =\u0026gt; _dataController.stream;  StreamController\u0026lt;String\u0026gt; _dataController = new StreamController.broadcast();   DataBloc(this._dataRepository);   Future\u0026lt;void\u0026gt; fetchData() async {  try {  _dataController.sink.add(await _dataRepository.getData());  } catch (e) {  _dataController.sink.addError(e);  }  }   void dispose() {  _dataController.close();  } }  abstract class DataRepository {  Future\u0026lt;String\u0026gt; getData(); }  class NetworkDataRepository implements DataRepository {  final ApiClient _apiClient;  final _token = \u0026#39;token\u0026#39;;   NetworkDataRepository(this._apiClient);   @override  Future\u0026lt;String\u0026gt; getData() async =\u0026gt; await _apiClient.sendRequest(  url: \u0026#39;www.google.com\u0026#39;, token: _token, requestBody: {\u0026#39;type\u0026#39;: \u0026#39;data\u0026#39;}); }  abstract class ApiClient {  Future sendRequest({@required String url, String token, Map requestBody}); }  class ApiClientMock implements ApiClient {  @override  Future sendRequest(  {@required String? url, String? token, Map? requestBody}) async {  return \u0026#39;Local Data\u0026#39;;  } }  class ApiClientImpl implements ApiClient {  @override  Future sendRequest(  {@required String? url, String? token, Map? requestBody}) async {  return \u0026#39;Network data\u0026#39;;  } } 5. Заключение #  На текущий момент библиотека используется в трех коммерческих проектах и собственных пет проектах.\n"},{"id":1,"href":"/cherrypick-site/docs/0_information/","title":"0 Information","section":"Docs","content":"Информация #  DI-контейнер #  DI-контейнер – это библиотека, которая обеспечивает функциональность механизма внедрения зависимостей.\nВозможности библиотеки #  Основные возможности DI контейнера:\n Инициализация экземпляра с именем Инициализация экземпляра как singleton Разделение контейнера на области видимости (scopes)  "},{"id":2,"href":"/cherrypick-site/docs/1_components/","title":"1 Components","section":"Docs","content":"Основные компоненты DI #  Библиотека состоит из трех основных компонентов:\n Scope Module Binding  Scope #  Scope - это контейнер, который хранит все дерево зависимостей (scope,modules,instances). Через scope можно получить доступ к instance, для этого нужно вызвать метод resolve\u0026lt;T\u0026gt;() и указать тип объекта, а так же можно передать дополнительные параметры.\nScope определяет область видимости и время жизни зависимостей.\nScope в приложении образуют древовидную иерархическую структуру. Например, у вас может быть Scope для всего приложения, и дочерний Scope для конкретного экрана или группы экранов.\nЧтобы получить объект Scope, его нужно “открыть”. Для простоты сделаем один Scope на всё приложение:\n final rootScope = CherryPick.openScope(named: \u0026#39;appScope\u0026#39;); Если повторно открыть Scope с тем же самым именем, мы получим уже существующий экземпляр Scope.\nКогда Scope перестанет быть нужным, его (и всё дерево “дочерних” Scope) можно будет закрыть с помощью метода CHerryPick.closeScope(name)\nModule #  Module - это набор правил, по которым CherryPick будет разрешать зависимости в конкретном Scope. Пользователь в своем модуле должен реализовать метод void builder(Scope currentScope). Модули добавляются в Scope с помощью метода scope.installModules(…), после чего Scope может разрешать зависимости по правилам, определённым в его модулях.\nПример:\nclass AppModule extends Module {  @override  void builder(Scope currentScope) {  bind\u0026lt;ApiClient\u0026gt;().toInstance(ApiClientMock());  } } Binding #  Binding - по сути это конфигуратор для пользовательского instance, который содержит методы для конфигурирования зависимости.\nЕсть два основных метода для инициализации пользовательского instance toInstance() и toProvide() и вспомогательных withName() и singleton().\ntoInstance() - принимает готовый экземпляр\ntoProvide() - принимает функцию provider (конструктор экземпляра)\nwithName() - принимает строку для именования экземпляра. По этому имени можно будет извлечь instance из DI контейнера\nsingleton() - устанавливает флаг в Binding, который говорит DI контейнеру, что зависимость одна.\nПример:\n // инициализация экземпляра текстовой строки через метод toInstance()  bind\u0026lt;String\u0026gt;().toInstance(\u0026#34;hello world\u0026#34;);   // или   // инициализация экземпляра текстовой строки  bind\u0026lt;String\u0026gt;().toProvide(() =\u0026gt; \u0026#34;hello world\u0026#34;);   // инициализация экземпляра строки с именем  bind\u0026lt;String\u0026gt;().withName(\u0026#34;my_string\u0026#34;).toInstance(\u0026#34;hello world\u0026#34;);  // или  bind\u0026lt;String\u0026gt;().withName(\u0026#34;my_string\u0026#34;).toProvide(() =\u0026gt; \u0026#34;hello world\u0026#34;);   // инициализация экземпляра, как singleton  bind\u0026lt;String\u0026gt;().toInstance(\u0026#34;hello world\u0026#34;);  // или  bind\u0026lt;String\u0026gt;().toProvide(() =\u0026gt; \u0026#34;hello world\u0026#34;).singleton(); "},{"id":3,"href":"/cherrypick-site/docs/2_install/","title":"2 Install","section":"Docs","content":"Подключение библиотеки #  Установите библиотеку #  Запустите команду:\nДля Dart проекта:\ndart pub add cherrypick Для Flutter проекта:\nflutter pub add cherrypick Команда добавит строку пакета cherrypick (и запустит в фоне неявно dart pub get):\ndependencies:  cherrypick: \u0026lt;version\u0026gt; Импортируйте библиотеку #  Теперь в вашем коде Dart вы можете использовать:\nimport \u0026#39;package:cherrypick/cherrypick.dart\u0026#39;; "},{"id":4,"href":"/cherrypick-site/docs/3_tutorial/","title":"3 Tutorial","section":"Docs","content":"Создайте первое приложение с применением CherryPick DI #  Шаг 1. Создайте приложение #  Используйте команду flutter create для создания нового проекта:\nflutter create sample_app cd sample_app Шаг 2. Добавьте зависимости #  dependencies:   cherrypick: ^1.0.2 # DI   shared_preferences: ^2.0.13   flutter_bloc: ^8.0.1  equatable: ^2.0.3   flutter_form_builder: ^7.1.1  form_builder_validators: ^8.1.1 Шаг 3. Напишите простое приложение для редактирования пользователя #  Добавьте модель пользователя в каталог проекта lib/user.dart: #  import \u0026#39;package:equatable/equatable.dart\u0026#39;;  class User extends Equatable {  final String name;  final String email;   const User({required this.name, required this.email});   const User.empty()  : name = \u0026#39;\u0026#39;,  email = \u0026#39;\u0026#39;;   @override  List\u0026lt;Object?\u0026gt; get props =\u0026gt; [name, email];   @override  bool? get stringify =\u0026gt; true; } Добавьте описание взаимодействия с репозиторием пользователя в каталог проекта lib/user_repository.dart: #  import \u0026#39;./user.dart\u0026#39;;  abstract class UserRepository {  User getUser();   void saveUser(User user); } Добавьте реализацию репозитория пользователя в каталог проекта lib/pref_user_repository.dart: #  import \u0026#39;package:shared_preferences/shared_preferences.dart\u0026#39;;  import \u0026#39;user.dart\u0026#39;; import \u0026#39;user_repository.dart\u0026#39;;  class PrefUserRepository extends UserRepository {  final SharedPreferences sharedPreferences;   static const String keyName = \u0026#34;KEY_NAME\u0026#34;;  static const String keyEmail = \u0026#34;KEY_EMAIL\u0026#34;;   PrefUserRepository({required this.sharedPreferences});   @override  User getUser() {  return User(  name: sharedPreferences.getString(keyName) ?? \u0026#39;\u0026#39;,  email: sharedPreferences.getString(keyEmail) ?? \u0026#39;\u0026#39;,  );  }   @override  void saveUser(User user) async {  await sharedPreferences.setString(keyName, user.name);  await sharedPreferences.setString(keyEmail, user.email);  } } Добавьте event-ы для UserBloc lib/bloc/user_bloc_event.dart: #  import \u0026#39;package:equatable/equatable.dart\u0026#39;; import \u0026#39;package:sample_app/user.dart\u0026#39;;  abstract class UserBlocEvent extends Equatable {  const UserBlocEvent();   factory UserBlocEvent.getUser() = GetUserEvent;   const factory UserBlocEvent.saveUser(User user) = SaveUserEvent; }  class GetUserEvent extends UserBlocEvent {  @override  List\u0026lt;Object?\u0026gt; get props =\u0026gt; []; }  class SaveUserEvent extends UserBlocEvent {  final User user;   const SaveUserEvent(this.user);   @override  List\u0026lt;Object?\u0026gt; get props =\u0026gt; [user]; } Добавьте state-ы для UserBloc lib/bloc/user_bloc_state.dart: #  import \u0026#39;package:equatable/equatable.dart\u0026#39;;  import \u0026#39;../user.dart\u0026#39;;  abstract class UserBlocState extends Equatable {  final User user;   const UserBlocState(this.user);   const factory UserBlocState.init(User user) = InitState;   const factory UserBlocState.successGetUser(User user) = SuccessGetUserState;   const factory UserBlocState.successSaveUser(User user) = SuccessSaveUserState;   @override  List\u0026lt;Object?\u0026gt; get props =\u0026gt; [user]; }  class InitState extends UserBlocState {  const InitState(User user) : super(user); }  class LoadingGetUserState extends UserBlocState {  const LoadingGetUserState(User user) : super(user); }  class SuccessGetUserState extends UserBlocState {  const SuccessGetUserState(User user) : super(user); }  class SuccessSaveUserState extends UserBlocState {  const SuccessSaveUserState(User user) : super(user); } Добавьте блок для управления репозиторием lib/bloc/user_bloc.dart: #  import \u0026#39;package:flutter/material.dart\u0026#39;; import \u0026#39;package:flutter_bloc/flutter_bloc.dart\u0026#39;; import \u0026#39;package:sample_app/bloc/user_bloc_event.dart\u0026#39;; import \u0026#39;package:sample_app/bloc/user_bloc_state.dart\u0026#39;; import \u0026#39;package:sample_app/user_repository.dart\u0026#39;;  import \u0026#39;../user.dart\u0026#39;;  class UserBloc extends Bloc\u0026lt;UserBlocEvent, UserBlocState\u0026gt; {  final UserRepository userRepository;   UserBloc({  required this.userRepository,  }) : super(const UserBlocState.init(User.empty())) {  on\u0026lt;GetUserEvent\u0026gt;(_onGetUserEvent);  on\u0026lt;SaveUserEvent\u0026gt;(_onSaveUserEvent);  }   void _onGetUserEvent(GetUserEvent event, emit) {  final user = userRepository.getUser();  emit(UserBlocState.successGetUser(user));  }   void _onSaveUserEvent(SaveUserEvent event, emit) {  userRepository.saveUser(event.user);  emit(UserBlocState.successSaveUser(event.user));  } } Добавьте экран редактирования пользователя lib/user_page.dart: #  import \u0026#39;package:cherrypick/cherrypick.dart\u0026#39;; import \u0026#39;package:flutter/material.dart\u0026#39;; import \u0026#39;package:flutter_bloc/flutter_bloc.dart\u0026#39;; import \u0026#39;package:flutter_form_builder/flutter_form_builder.dart\u0026#39;; import \u0026#39;package:form_builder_validators/form_builder_validators.dart\u0026#39;; import \u0026#39;package:sample_app/bloc/user_bloc.dart\u0026#39;; import \u0026#39;package:sample_app/bloc/user_bloc_event.dart\u0026#39;; import \u0026#39;package:sample_app/bloc/user_bloc_state.dart\u0026#39;; import \u0026#39;package:sample_app/di/scopes.dart\u0026#39;; import \u0026#39;package:sample_app/user.dart\u0026#39;;  class UserPage extends StatelessWidget {  UserPage({Key? key, required this.title}) : super(key: key);   final String title;   final _formKey = GlobalKey\u0026lt;FormBuilderState\u0026gt;();   @override  Widget build(BuildContext context) {  return BlocProvider\u0026lt;UserBloc\u0026gt;(  create: (context) {  return CherryPick.openScope(scopeName: Scopes.APP_SCOPE)  .resolve\u0026lt;UserBloc\u0026gt;();  },  child: BlocBuilder\u0026lt;UserBloc, UserBlocState\u0026gt;(  builder: ((context, state) {  return Scaffold(  appBar: AppBar(  title: Text(title),  ),  body: Column(  children: [  Text(state.user.toString()),  const SizedBox(width: 20),  FormBuilder(  key: _formKey,  child: Column(  children: [  FormBuilderTextField(  name: \u0026#39;name\u0026#39;,  decoration: const InputDecoration(labelText: \u0026#39;Name\u0026#39;),  keyboardType: TextInputType.text,  validator: FormBuilderValidators.compose([  FormBuilderValidators.required\u0026lt;String\u0026gt;(),  ]),  ),  FormBuilderTextField(  name: \u0026#39;email\u0026#39;,  decoration: const InputDecoration(labelText: \u0026#39;Email\u0026#39;),  keyboardType: TextInputType.text,  validator: FormBuilderValidators.compose([  FormBuilderValidators.required\u0026lt;String\u0026gt;(),  ]),  ),  ],  ),  ),  const SizedBox(width: 20),  MaterialButton(  color: Theme.of(context).colorScheme.secondary,  child: const Text(  \u0026#34;Save\u0026#34;,  style: TextStyle(color: Colors.white),  ),  onPressed: () {  _formKey.currentState?.saveAndValidate();  BlocProvider.of\u0026lt;UserBloc\u0026gt;(context).add(  UserBlocEvent.saveUser(  User(  name: _formKey.currentState?.fields[\u0026#39;name\u0026#39;]?.value ??  \u0026#39;\u0026#39;,  email:  _formKey.currentState?.fields[\u0026#39;email\u0026#39;]?.value ??  \u0026#39;\u0026#39;,  ),  ),  );  },  ),  ],  ),  );  }),  ),  );  } } Добавьте главный виджет lib/app.dart: #  import \u0026#39;package:flutter/material.dart\u0026#39;;  import \u0026#39;user_page.dart\u0026#39;;  class App extends StatelessWidget {  const App({Key? key}) : super(key: key);   @override  Widget build(BuildContext context) {  return MaterialApp(  title: \u0026#39;Sample App\u0026#39;,  theme: ThemeData(  primarySwatch: Colors.blue,  ),  home: UserPage(title: \u0026#39;Sample App\u0026#39;),  );  } } Добавьте di модуль lib/di/user_module.dart: #  В модуле UserModule описываем все зависимости. Из кода видно что UserBloc зависит от UserRepository.\nimport \u0026#39;package:cherrypick/cherrypick.dart\u0026#39;; import \u0026#39;package:sample_app/bloc/user_bloc.dart\u0026#39;; import \u0026#39;package:sample_app/pref_user_repository.dart\u0026#39;; import \u0026#39;package:sample_app/user_repository.dart\u0026#39;; import \u0026#39;package:shared_preferences/shared_preferences.dart\u0026#39;;  class UserModule extends Module {  final SharedPreferences sharedPreferences;   UserModule({required this.sharedPreferences});   @override  void builder(Scope currentScope) {  bind\u0026lt;UserRepository\u0026gt;()  .toProvide(  () =\u0026gt; PrefUserRepository(sharedPreferences: sharedPreferences))  .singleton();   bind\u0026lt;UserBloc\u0026gt;().toProvide(  () =\u0026gt; UserBloc(  userRepository: currentScope.resolve\u0026lt;UserRepository\u0026gt;(),  ),  );  } } Добавьте имя scope lib/di/scopes.dart: #  class Scopes {  static const String appScope = \u0026#39;appScope\u0026#39;; } Добавьте функцию main в lib/main.dart: #  import \u0026#39;package:cherrypick/cherrypick.dart\u0026#39;; import \u0026#39;package:flutter/material.dart\u0026#39;; import \u0026#39;package:sample_app/di/user_module.dart\u0026#39;; import \u0026#39;package:sample_app/di/scopes.dart\u0026#39;; import \u0026#39;package:shared_preferences/shared_preferences.dart\u0026#39;;  import \u0026#39;./app.dart\u0026#39;;  void main() async {  final sharedPreferences = await SharedPreferences.getInstance();   final appScope = CherryPick.openScope(scopeName: Scopes.appScope);   appScope.installModules(  [  UserModule(sharedPreferences: sharedPreferences),  ],  );   runApp(const App()); } Если посмотреть на тело функции main(), то можно увидеть, что инициализация di происходит в два этапа:\n1 Открытие scope\n final appScope = CherryPick.openScope(scopeName: Scopes.appScope); 1 Инициализация модуля UserModule в scope appScope\nappScope.installModules(  [  UserModule(sharedPreferences: sharedPreferences),  ],  ); Шаг 4. Запустите приложение #  Используйте команду flutter run для запуска приложения:\nflutter run "}]